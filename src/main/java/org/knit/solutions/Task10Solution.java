package org.knit.solutions;

import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;

import org.knit.TaskDescription;
import org.knit.solutions.Task10.Runner;

/*
üìå –û–ø–∏—Å–∞–Ω–∏–µ
–ì—Ä—É–ø–ø–∞ —Å–ø–æ—Ä—Ç—Å–º–µ–Ω–æ–≤ —É—á–∞—Å—Ç–≤—É–µ—Ç –≤ –∑–∞–±–µ–≥–µ. –û–¥–Ω–∞–∫–æ –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º –≥–æ–Ω–∫–∏ –≤—Å–µ –¥–æ–ª–∂–Ω—ã —Å–æ–±—Ä–∞—Ç—å—Å—è –Ω–∞ —Å—Ç–∞—Ä—Ç–µ.
–ö–∞–∫ —Ç–æ–ª—å–∫–æ –≤—Å–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏ –±—É–¥—É—Ç –≥–æ—Ç–æ–≤—ã, –∑–∞–±–µ–≥ –Ω–∞—á–Ω—ë—Ç—Å—è –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ.
–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ CyclicBarrier, —á—Ç–æ–±—ã —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∑–∞–ø—É—Å–∫ –≥–æ–Ω–∫–∏.

–ö–∞–∂–¥—ã–π –±–µ–≥—É–Ω —Å—Ç–∞—Ä—Ç—É–µ—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ, –∑–∞—Ç–µ–º –±–µ–∂–∏—Ç —Ä–∞–∑–Ω–æ–µ –≤—Ä–µ–º—è (—Å–∏–º—É–ª–∏—Ä—É–µ—Ç—Å—è Thread.sleep), –ø–æ—Å–ª–µ —á–µ–≥–æ —Ñ–∏–Ω–∏—à–∏—Ä—É–µ—Ç.
–ö–∞–∫ —Ç–æ–ª—å–∫–æ –≤—Å–µ –±–µ–≥—É–Ω—ã –∑–∞–≤–µ—Ä—à–∞—Ç –¥–∏—Å—Ç–∞–Ω—Ü–∏—é, –ø—Ä–æ–≥—Ä–∞–º–º–∞ –≤—ã–≤–æ–¥–∏—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –≥–æ–Ω–∫–∏.

üéØ –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –∑–∞–¥–∞—á–µ:
1) –°–æ–∑–¥–∞—Ç—å CyclicBarrier –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –Ω–∞—á–∞–ª–∞ –∑–∞–±–µ–≥–∞.
2) –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∫–ª–∞—Å—Å Runner, –∫–æ—Ç–æ—Ä—ã–π:
   - –û–∂–∏–¥–∞–µ—Ç —Å—Ç–∞—Ä—Ç–∞ (barrier.await()).
   - –°–∏–º—É–ª–∏—Ä—É–µ—Ç –±–µ–≥ (Thread.sleep(randomTime)).
   - –í—ã–≤–æ–¥–∏—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ —Ñ–∏–Ω–∏—à–µ.
3) –ü–æ—Å–ª–µ —Ñ–∏–Ω–∏—à–∞ –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –¥–æ–ª–∂–Ω–∞ —Å–æ–æ–±—â–∏—Ç—å, —á—Ç–æ –≥–æ–Ω–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.
4) –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–µ–≥—É–Ω–æ–≤ –∑–∞–¥–∞—ë—Ç—Å—è –∫–æ–Ω—Å—Ç–∞–Ω—Ç–æ–π (–∏–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º).

üîß –ü–æ–¥—Å–∫–∞–∑–∫–∞
–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ Executors.newFixedThreadPool() –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ—Ç–æ–∫–∞–º–∏.
–î–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–ª—É—á–∞–π–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –±–µ–≥–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ ThreadLocalRandom.current().nextInt(500, 3000).

üîπ –î–æ–ø. –∑–∞–¥–∞–Ω–∏–µ (–≤—ã–ø–æ–ª–Ω–µ–Ω–æ –≤ –∫–æ–¥–µ –Ω–∏–∂–µ):
- –ï—Å—Ç—å –≤—Ç–æ—Ä–æ–π barrier, –æ–∂–∏–¥–∞—é—â–∏–π –≤—Å–µ—Ö –±–µ–≥—É–Ω–æ–≤ –Ω–∞ —Ñ–∏–Ω–∏—à–µ.
- –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –≥–æ–Ω–∫–∏, –µ—Å–ª–∏ –æ–¥–∏–Ω –∏–∑ –±–µ–≥—É–Ω–æ–≤ "–ø–æ–ª—É—á–∏–ª —Ç—Ä–∞–≤–º—É".
 */

@TaskDescription(taskNumber = 10, taskDescription = "–ì–æ–Ω–∫–∞ –±–µ–≥—É–Ω–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º CyclicBarrier")
public class Task10Solution implements Solution {
    @Override
    public void execute() {
        System.out.println("–ó–∞–¥–∞—á–∞ 10 –∑–∞–ø—É—â–µ–Ω–∞");

        final int numRunners = 5;

        AtomicBoolean raceInterrupted = new AtomicBoolean(false);

        CyclicBarrier startBarrier = new CyclicBarrier(numRunners, () ->
                System.out.println("–í—Å–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏ –≥–æ—Ç–æ–≤—ã. –ù–∞—á–∏–Ω–∞–µ–º –∑–∞–±–µ–≥!")
        );

        CyclicBarrier finishBarrier = new CyclicBarrier(numRunners, () ->
                System.out.println("–í—Å–µ –±–µ–≥—É–Ω—ã —Ñ–∏–Ω–∏—à–∏—Ä–æ–≤–∞–ª–∏. –ó–∞–±–µ–≥ –∑–∞–≤–µ—Ä—à—ë–Ω!")
        );

        ExecutorService executor = Executors.newFixedThreadPool(numRunners);
        try {
            for (int i = 0; i < numRunners; i++) {
                String runnerName = "–ë–µ–≥—É–Ω-" + (i + 1);
                executor.submit(new Runner(runnerName, startBarrier, finishBarrier, raceInterrupted));
            }
        } finally {
            executor.shutdown();
        }

        try {
            boolean finishedInTime = executor.awaitTermination(10, TimeUnit.SECONDS);
            if (!finishedInTime) {
                System.out.println("–í–Ω–∏–º–∞–Ω–∏–µ: –Ω–µ –≤—Å–µ –±–µ–≥—É–Ω—ã —É—Å–ø–µ–ª–∏ —Ñ–∏–Ω–∏—à–∏—Ä–æ–≤–∞—Ç—å –∑–∞ 10 —Å–µ–∫—É–Ω–¥.");
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            System.out.println("–ì–ª–∞–≤–Ω—ã–π –ø–æ—Ç–æ–∫ –ø—Ä–µ—Ä–≤–∞–Ω –≤–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∑–∞–±–µ–≥–∞.");
            Thread.currentThread().interrupt();
        }

        if (raceInterrupted.get()) {
            System.out.println("–ó–∞–±–µ–≥ –±—ã–ª –ø—Ä–µ—Ä–≤–∞–Ω –∏–∑-–∑–∞ —Ç—Ä–∞–≤–º—ã –æ–¥–Ω–æ–≥–æ –∏–∑ –±–µ–≥—É–Ω–æ–≤.");
        }
    }
}
