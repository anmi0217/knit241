### Задача № 18
### **Условие задачи:**
Дан массив целых чисел `arr` фиксированной длины. Необходимо продублировать каждое вхождение нуля, сдвигая остальные элементы вправо.

**Примечание:**
- Элементы, выходящие за пределы исходного массива, не записываются.
- Изменения нужно выполнить **на месте** (in-place), не возвращая новый массив.

---

### **Пример 1:**
**Вход:** `arr = [1,0,2,3,0,4,5,0]`  
**Выход:** `[1,0,0,2,3,0,0,4]`  
**Объяснение:**
- Ноль после `1` дублируется → `[1,0,0,2,3,0,4,5]`
- Ноль после `3` дублируется → `[1,0,0,2,3,0,0,4]` (последний `0` выходит за границы и отбрасывается)

### **Пример 2:**
**Вход:** `arr = [1,2,3]`  
**Выход:** `[1,2,3]`  
**Объяснение:** В массиве нет нулей, поэтому он остаётся без изменений.

### **Ограничения:**
- `1 <= arr.length <= 10^4`
- `0 <= arr[i] <= 9`


### Напишите решение, а затем Напишите JUnit тесты для проверки решения

### Тесты должны покрывать 

--Обычные случаи (с нулями и без).

--Краевые случаи (пустые массивы, все нули, нули на границах).

--Производительность (большие массивы) . // просто зафиксировать время выполнения по производительности эмпирическим путем


```java
/**
 * Дублирует каждый ноль в массиве, сдвигая элементы вправо.
 * Элементы, выходящие за границы массива, отбрасываются.
 * 
 * @param arr Входной массив (изменяется на месте)
 */
public void duplicateZeros(int[] arr) {
   
}
```

### Задача 19

### **Условие задачи:**

Даны два целочисленных массива `nums1` и `nums2`, отсортированных в **неубывающем порядке**, а также два целых числа `m` и `n`, представляющих количество элементов в `nums1` и `nums2` соответственно.

**Требуется:**  
Объединить `nums1` и `nums2` в один массив, отсортированный в **неубывающем порядке**.

**Важные условия:**
1. Итоговый отсортированный массив должен быть сохранён **внутри массива `nums1`** (функция не должна ничего возвращать).
2. Массив `nums1` имеет длину `m + n`, где:
    - Первые `m` элементов — значимые (их нужно объединять с `nums2`).
    - Последние `n` элементов заполнены нулями и должны быть проигнорированы.
3. Длина `nums2` равна `n`.

---

### **Пример 1:**
**Входные данные:**  
`nums1 = [1, 2, 3, 0, 0, 0]`, `m = 3`  
`nums2 = [2, 5, 6]`, `n = 3`

**Результат:**  
`[1, 2, 2, 3, 5, 6]`

**Объяснение:**  
Объединяемые массивы: `[1, 2, 3]` и `[2, 5, 6]`.  
Результат — `[1, 2, 2, 3, 5, 6]` (подчёркнутые элементы взяты из `nums1`).

---

### **Пример 2:**
**Входные данные:**  
`nums1 = [1]`, `m = 1`  
`nums2 = []`, `n = 0`

**Результат:**  
`[1]`

**Объяснение:**  
Объединяемые массивы: `[1]` и `[]`.  
Результат — `[1]`.

---

### **Пример 3:**
**Входные данные:**  
`nums1 = [0]`, `m = 0`  
`nums2 = [1]`, `n = 1`

**Результат:**  
`[1]`

**Объяснение:**  
Объединяемые массивы: `[]` и `[1]`.  
Поскольку `m = 0`, в `nums1` нет значимых элементов (нули служат только для резерва места).

---

### **Ограничения:**
- `nums1.length == m + n`
- `nums2.length == n`
- `0 <= m, n <= 200`
- `1 <= m + n <= 200`
- `-10^9 <= nums1[i], nums2[j] <= 10^9`

---

### **Примечания:**
- Нельзя использовать дополнительную память для создания нового массива (кроме временных переменных).
- Решение должно работать **за линейное время** `O(m + n)`.

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        
    }
}
```

### Напишите решение, а затем Напишите JUnit тесты для проверки решения

### Тесты должны покрывать 

--Обычные случаи (слияние с данными и без).

--Краевые случаи (пустые массивы, все элементы в одном массиве).

--Отрицательные числа и дубликаты.

--Производительность (большие массивы) // просто зафиксировать время выполнения по производительности эмпирическим путем.