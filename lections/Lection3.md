# Лекция № 3

## Массивы, строки.

Лекция: **Массивы и строки в Java**

### 1. Массивы
Массивы в Java — это структуры данных, которые позволяют хранить несколько элементов одного типа в одном контейнере. Массивы имеют фиксированный размер и хранят элементы в смежных ячейках памяти.

#### 1.1. Объявление массива
Для создания массива нужно указать тип данных элементов массива и его длину.

Пример объявления массива целых чисел:

```java
int[] numbers = new int[5]; // массив из 5 элементов
```

Здесь:
- `int[]` указывает, что это массив целых чисел.
- `new int[5]` — создание нового массива из 5 элементов, которые по умолчанию равны 0.

Массив можно сразу инициализировать:

```java
int[] numbers = {1, 2, 3, 4, 5};
```

#### 1.2. Индексация массива
Элементы массива можно получать и изменять по индексу. Индексация начинается с 0.

```java
int firstElement = numbers[0]; // Получаем первый элемент
numbers[1] = 10; // Изменяем второй элемент
```

#### 1.3. Длина массива
У каждого массива есть поле `length`, которое возвращает количество элементов в массиве.

```java
int length = numbers.length; // длина массива
```

#### 1.4. Перебор массива
Для перебора массива часто используют цикл `for` или `for-each`:

```java
for (int i = 0; i < numbers.length; i++) {
    System.out.println(numbers[i]);
}

for (int number : numbers) {
    System.out.println(number);
}
```

#### 1.5. Многомерные массивы
Java поддерживает многомерные массивы, которые можно рассматривать как массивы массивов.

Пример двумерного массива:

```java
int[][] matrix = new int[3][3];
matrix[0][0] = 1; // первый элемент первого подмассива
```

Инициализация двумерного массива:

```java
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
```
Сравнение массивов в Java имеет несколько особенностей, которые важно понимать, так как массивы являются объектами, а не примитивными типами. Это означает, что при сравнении массивов напрямую с помощью операторов или методов нужно учитывать несколько нюансов.

### 1. Сравнение массивов с помощью оператора `==`
Когда мы используем оператор `==` для сравнения двух массивов, он сравнивает **ссылки** на объекты массивов, а не их содержимое. Это означает, что если два массива указывают на один и тот же объект в памяти, результат будет `true`, в противном случае — `false`.

Пример:

```java
int[] array1 = {1, 2, 3};
int[] array2 = {1, 2, 3};
int[] array3 = array1;

System.out.println(array1 == array2); // false, так как это два разных объекта
System.out.println(array1 == array3); // true, так как оба ссылаются на один и тот же объект
```

### 2. Сравнение массивов с помощью метода `equals()`
Метод `equals()` в классе `Object` (который наследуют все классы в Java, включая массивы) также сравнивает массивы по **ссылкам**, а не по их содержимому. Это аналогично оператору `==`.

Пример:

```java
System.out.println(array1.equals(array2)); // false, так как это разные объекты
System.out.println(array1.equals(array3)); // true, так как это один и тот же объект
```

### 3. Сравнение содержимого массивов с помощью класса `Arrays`
Чтобы корректно сравнить **содержимое** массивов (например, одинаковые ли элементы и их порядок), Java предоставляет специальный утилитный класс `java.util.Arrays`, который содержит методы для работы с массивами, включая их сравнение.

#### 3.1. `Arrays.equals()`
Метод `Arrays.equals()` сравнивает два массива **по элементам**, а не по ссылкам. Он возвращает `true`, если оба массива имеют одинаковую длину и все соответствующие элементы равны.

Пример для одномерного массива:

```java
int[] array1 = {1, 2, 3};
int[] array2 = {1, 2, 3};

System.out.println(Arrays.equals(array1, array2)); // true, так как массивы равны по содержимому
```

Пример для двумерного массива:

```java
int[][] matrix1 = {{1, 2}, {3, 4}};
int[][] matrix2 = {{1, 2}, {3, 4}};

System.out.println(Arrays.equals(matrix1, matrix2)); // false, так как двумерные массивы сравниваются по ссылкам
```

#### 3.2. `Arrays.deepEquals()`
Для сравнения многомерных массивов по содержимому используется метод `Arrays.deepEquals()`. Он рекурсивно сравнивает содержимое всех подмассивов.

Пример:

```java
System.out.println(Arrays.deepEquals(matrix1, matrix2)); // true, так как содержимое двухмерных массивов одинаково
```

### 4. Сортировка массивов перед сравнением
В некоторых случаях, если порядок элементов не имеет значения, массивы нужно сначала отсортировать перед их сравнением:

```java
int[] array1 = {3, 2, 1};
int[] array2 = {1, 2, 3};

// Сортируем массивы
Arrays.sort(array1);
Arrays.sort(array2);

System.out.println(Arrays.equals(array1, array2)); // true, так как после сортировки массивы равны
```

### 5. Особенности сравнения массивов объектов
Если массив состоит из объектов (например, массив строк), то при сравнении содержимого с помощью `Arrays.equals()` вызывается метод `equals()` для каждого объекта.

Пример:

```java
String[] array1 = {"Java", "Python"};
String[] array2 = {"Java", "Python"};

System.out.println(Arrays.equals(array1, array2)); // true, так как строки одинаковы
```

Однако если массив состоит из объектов пользовательских классов, для корректного сравнения нужно переопределить метод `equals()` в этих классах.

- Оператор `==` и метод `equals()` сравнивают массивы по **ссылкам**, а не по содержимому.
- Для сравнения содержимого массивов следует использовать `Arrays.equals()` для одномерных массивов и `Arrays.deepEquals()` для многомерных.
- Если массивы содержат объекты пользовательских классов, необходимо переопределять метод `equals()` в этих классах для правильного сравнения.


### 2. Строки
В Java строки представлены классом `String`. Строка — это неизменяемый объект, представляющий последовательность символов. Любое изменение строки приводит к созданию нового объекта.

#### 2.1. Создание строки
Есть несколько способов создания строки:

```java
String str1 = "Hello";
String str2 = new String("World");
```

Строка, созданная с использованием кавычек, попадает в **пул строк**, а строка, созданная через `new`, всегда создается в памяти, даже если аналогичная строка уже существует в пуле.

#### 2.2. Основные методы класса String
- `length()`: возвращает длину строки.

```java
int length = str1.length();
```

- `charAt(int index)`: возвращает символ по индексу.

```java
char ch = str1.charAt(0); // 'H'
```

- `substring(int beginIndex, int endIndex)`: возвращает подстроку.

```java
String sub = str1.substring(1, 4); // "ell"
```

- `equals(Object anObject)`: сравнивает строки на равенство.

```java
boolean isEqual = str1.equals("Hello");
```

- `toLowerCase()` и `toUpperCase()`: преобразуют строку в нижний или верхний регистр.

```java
String lower = str1.toLowerCase(); // "hello"
String upper = str1.toUpperCase(); // "HELLO"
```

- `replace(char oldChar, char newChar)`: заменяет символы в строке.

```java
String newStr = str1.replace('e', 'a'); // "Hallo"
```

- `trim()`: убирает пробелы в начале и в конце строки.

```java
String trimmedStr = str2.trim();
```

#### 2.3. Конкатенация строк
Для объединения строк используется оператор `+` или метод `concat()`:

```java
String full = str1 + " " + str2; // "Hello World"
String concatenated = str1.concat(" ").concat(str2);
```

#### 2.4. Преобразование строки в массив символов
С помощью метода `toCharArray()` можно преобразовать строку в массив символов:

```java
char[] charArray = str1.toCharArray();
```

### 3. Пример работы с массивами и строками
Напишем небольшой пример, где создадим массив строк и выведем их в обратном порядке.

```java
public class Main {
    public static void main(String[] args) {
        String[] words = {"Java", "is", "awesome"};
        
        // Выводим строки в обратном порядке
        for (int i = words.length - 1; i >= 0; i--) {
            System.out.print(words[i] + " ");
        }
    }
}
```

В Java классы `String`, `StringBuilder` и `StringBuffer` предоставляют различные подходы для работы со строками, и у каждого есть свои особенности и применения. Давайте разберемся с основными отличиями и особенностями каждого из них.

### 1. **String**

#### 1.1. Особенности
- **Неизменяемый (Immutable)**: Строки в Java неизменяемы. Это означает, что после создания строки её содержимое изменить невозможно. Любое изменение строки, такое как конкатенация или замена символов, создает новый объект строки в памяти.
- **Пул строк**: Когда строка создается через литералы (например, `String s = "Hello";`), она помещается в **пул строк**. Если строка с таким же значением уже существует в пуле, новая строка не будет создана — будет использоваться существующая строка.

#### 1.2. Пример:
```java
String str = "Hello";
str = str + " World"; // Создается новый объект строки, старая строка не изменяется
```

#### 1.3. Применение:
- Используйте `String`, когда вам не нужно изменять строку. Это предпочтительный класс для работы с неизменными значениями, так как он более безопасен с точки зрения производительности и памяти при малом количестве изменений.

---

### 2. **StringBuilder**

#### 2.1. Особенности
- **Изменяемый (Mutable)**: В отличие от `String`, `StringBuilder` позволяет изменять строку без создания нового объекта.
- **Не синхронизирован**: `StringBuilder` не является потокобезопасным, что делает его неподходящим для использования в многопоточных приложениях. Однако отсутствие синхронизации делает его более быстрым при работе с одной нитью.

#### 2.2. Пример:
```java
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World"); // Изменение строки без создания нового объекта
System.out.println(sb.toString()); // "Hello World"
```

#### 2.3. Применение:
- Используйте `StringBuilder`, когда вам нужно часто изменять строки (например, при конкатенации или форматировании), и ваше приложение не работает в многопоточной среде. Он более эффективен по сравнению с `String` в сценариях, где выполняется много изменений строки.

---

### 3. **StringBuffer**

#### 3.1. Особенности
- **Изменяемый (Mutable)**: Как и `StringBuilder`, `StringBuffer` предоставляет изменяемую строку.
- **Синхронизирован**: В отличие от `StringBuilder`, `StringBuffer` является потокобезопасным, что означает, что он может использоваться в многопоточных приложениях. Однако синхронизация делает его немного медленнее, чем `StringBuilder`.

#### 3.2. Пример:
```java
StringBuffer sbf = new StringBuffer("Hello");
sbf.append(" World"); // Потокобезопасное изменение строки
System.out.println(sbf.toString()); // "Hello World"
```

#### 3.3. Применение:
- Используйте `StringBuffer`, если вам нужно изменять строки в многопоточной среде. Если потокобезопасность не важна, предпочтительнее использовать `StringBuilder` для повышения производительности.

---

### 4. **Сравнительная таблица**

| Характеристика            | String          | StringBuilder     | StringBuffer      |
|---------------------------|-----------------|-------------------|-------------------|
| **Изменяемость**           | Неизменяемый    | Изменяемый        | Изменяемый        |
| **Потокобезопасность**     | Нет             | Нет               | Да                |
| **Производительность**     | Медленный при частых изменениях | Быстрее при частых изменениях | Медленнее, чем `StringBuilder` из-за синхронизации |
| **Пул строк**              | Да              | Нет               | Нет               |
| **Когда использовать**     | Когда строки неизменны | Когда нужно изменять строки в однопоточной среде | Когда нужно изменять строки в многопоточной среде |

---

### 5. **Примеры использования на практике**

#### Пример 1: Использование `String`
Когда строки не изменяются после создания, например, для хранения постоянных данных:

```java
String greeting = "Hello";
String farewell = "Goodbye";
```

#### Пример 2: Использование `StringBuilder` для конкатенации строк
Когда вам нужно создать строку путем выполнения множества изменений, например, в цикле:

```java
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 10; i++) {
    sb.append(i).append(" ");
}
System.out.println(sb.toString());
```

#### Пример 3: Использование `StringBuffer` в многопоточном приложении
Когда работа с строками должна быть синхронизирована между потоками:

```java
StringBuffer sharedBuffer = new StringBuffer();
synchronized(sharedBuffer) {
    sharedBuffer.append("Thread-safe string operation");
}
```

- `String` подходит для неизменных строк и постоянных данных.
- `StringBuilder` предпочтителен в однопоточных приложениях, где нужно часто изменять строки.
- `StringBuffer` используется в многопоточных приложениях, где важна синхронизированность и потокобезопасность.



