### 2. Иерархия интерфейсов коллекций

![Pasted image 20241025120843.png](Pasted%20image%2020241025120843.png)

![Pasted image 20241025121934.png](Pasted%20image%2020241025121934.png)

#### 2.1 Коллекции в Java: Обзор иерархии интерфейсов

В Java коллекции являются фундаментальной частью API и предоставляют мощные инструменты для работы с группами объектов. Иерархия коллекций строится вокруг нескольких основных интерфейсов, начиная с `Collection`. 

#### Основная структура иерархии:
- **Collection (интерфейс)**: Базовый интерфейс, определяющий общий функционал для всех коллекций. Этот интерфейс служит основой для более специализированных коллекций и включает методы для добавления, удаления, поиска элементов, проверки размера и проверки, пуста ли коллекция.
- **List, Set, Queue и Deque** — основные специализированные интерфейсы, которые наследуются от `Collection`.

##### 2.1.1 Интерфейс `List`
- **Описание:** Представляет собой упорядоченную коллекцию элементов, которая допускает дублирование. Элементы имеют свои индексы, начиная с 0, что позволяет обращаться к элементам по индексу, добавлять и удалять элементы в конкретных позициях.
- **Примеры классов:**
  - **`ArrayList`**: Реализует массив с динамическим размером, обеспечивает быстрый доступ по индексу (O(1)), но медленные операции вставки и удаления в середине (O(n)).
  - **`LinkedList`**: Двусвязный список, обеспечивающий быструю вставку и удаление элементов (O(1)), но более медленный доступ по индексу (O(n)).

##### 2.1.2 Интерфейс `Set`
- **Описание:** Коллекция, которая не допускает дубликатов и не гарантирует определенного порядка элементов (если это не специализированная реализация). Основное предназначение — хранить уникальные элементы.
- **Примеры классов:**
  - **`HashSet`**: Основан на хеш-таблице, обеспечивает быстрые операции вставки, удаления и поиска (в среднем O(1)), но не гарантирует порядок элементов.
  - **`TreeSet`**: Основан на красно-черном дереве, поддерживает элементы в отсортированном порядке и обеспечивает сложность операций O(log n).
  - **`LinkedHashSet`**: Сохраняет порядок добавления элементов, при этом обеспечивая эффективность операций как у `HashSet`.

##### 2.1.3 Интерфейс `Queue`
- **Описание:** Коллекция, работающая по принципу "первым пришел — первым вышел" (FIFO). Основное использование — управление задачами и буферами.
- **Примеры классов:**
  - **`PriorityQueue`**: Очередь с приоритетами, где элементы извлекаются в порядке их приоритета (минимальный или максимальный элемент), основана на куче (heap), операции добавления и удаления занимают O(log n).
  - **`LinkedList`**: Может использоваться как очередь, благодаря реализации интерфейса `Queue`, поддерживает вставку и удаление как с головы, так и с хвоста.

##### 2.1.4 Интерфейс `Deque`
- **Описание:** Двусторонняя очередь (double-ended queue), которая поддерживает вставку и удаление элементов как с начала, так и с конца. Может работать и как стек (LIFO), и как очередь (FIFO).
- **Примеры классов:**
  - **`ArrayDeque`**: Реализует двустороннюю очередь на базе массива, обеспечивает эффективные вставку и удаление элементов с обеих сторон (O(1)), но не гарантирует порядок.

#### 2.2 Интерфейс `Map`

![Pasted image 20241025120944.png](Pasted%20image%2020241025120944.png)

`Map` — это отдельный интерфейс, который отличается от иерархии `Collection`. Он используется для хранения пар ключ-значение, где каждый ключ уникален. `Map` не является частью иерархии `Collection`, потому что он не хранит просто набор элементов, а хранит ассоциированные пары ключ-значение.

- **Примеры классов:**
  - **`HashMap`**: Основан на хеш-таблице, обеспечивает быстрый доступ по ключу (в среднем O(1)), не сохраняет порядок элементов.
  - **`TreeMap`**: Основан на красно-черном дереве, поддерживает элементы отсортированными по ключу, операции вставки, удаления и поиска занимают O(log n).
  - **`LinkedHashMap`**: Сохраняет порядок вставки элементов или порядок их доступа (если используется в качестве кэша), и поддерживает те же операции, что и `HashMap`.

#### 2.3 Примеры классов, реализующих эти интерфейсы
- **`ArrayList` и `LinkedList`** реализуют интерфейс `List`, предоставляя возможности работы с упорядоченными коллекциями.
- **`HashSet`, `TreeSet`, и `LinkedHashSet`** реализуют интерфейс `Set`, позволяя хранить уникальные элементы в различном порядке (без порядка, отсортированном или порядке вставки).
- **`PriorityQueue` и `ArrayDeque`** реализуют интерфейсы `Queue` и `Deque` для работы с очередями и двусторонними очередями.
- **`HashMap`, `TreeMap`, и `LinkedHashMap`** — классы, реализующие интерфейс `Map`, предоставляющие функционал для хранения и быстрого доступа к парам ключ-значение.

