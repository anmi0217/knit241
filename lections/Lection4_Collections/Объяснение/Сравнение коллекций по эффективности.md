### 4. Сравнение коллекций по эффективности (таблица O(n))

В этой части лекции важно рассмотреть, как различные реализации коллекций справляются с базовыми операциями. Это поможет понять, в каких случаях стоит использовать ту или иную коллекцию для оптимизации производительности. Мы обсудим операции добавления (`add`), удаления (`remove`), проверки наличия (`contains`) и доступа к элементу (`get`). 

#### 4.1 Таблица сложности операций для коллекций

| Коллекция      | Добавление (add) | Удаление (remove) | Поиск (contains) | Доступ (get) |
|----------------|------------------|-------------------|------------------|--------------|
| `ArrayList`    | O(1)*            | O(n)              | O(n)             | O(1)         |
| `LinkedList`   | O(1)**           | O(1)**            | O(n)             | O(n)         |
| `HashSet`      | O(1)             | O(1)              | O(1)             | N/A          |
| `TreeSet`      | O(log n)         | O(log n)          | O(log n)         | N/A          |
| `HashMap`      | O(1)             | O(1)              | O(1)             | O(1)         |
| `TreeMap`      | O(log n)         | O(log n)          | O(log n)         | O(log n)     |
| `PriorityQueue`| O(log n)         | O(log n)          | O(n)             | O(n)         |
| `ArrayDeque`   | O(1)             | O(1)              | O(n)             | N/A          |

\* Добавление в `ArrayList` имеет среднюю сложность O(1), но если массив переполняется и требуется его увеличение, то сложность возрастает до O(n).  
\** Вставка и удаление в `LinkedList` происходят за O(1), если известен узел, на котором выполняется операция.

#### 4.2 Объяснение таблицы и выбор коллекции в зависимости от задачи

1. **`ArrayList`**
   - **Когда использовать:** 
     - Если требуется частый доступ к элементам по индексу, и операции добавления/удаления происходят в основном в конце списка.
   - **Когда не использовать:** 
     - Если требуется часто добавлять или удалять элементы в середине или начале списка, так как это требует сдвига элементов и имеет сложность O(n).

2. **`LinkedList`**
   - **Когда использовать:** 
     - Если необходимо часто добавлять или удалять элементы в начале или середине списка, так как эти операции происходят за O(1).
   - **Когда не использовать:** 
     - Если требуется частый доступ по индексу, так как доступ происходит за O(n).

3. **`HashSet`**
   - **Когда использовать:** 
     - Если нужно быстро добавлять, удалять и проверять наличие элементов, и порядок не имеет значения. 
   - **Когда не использовать:** 
     - Если требуется отсортированный порядок элементов или поддержка порядка вставки.

4. **`TreeSet`**
   - **Когда использовать:** 
     - Если важен порядок элементов (например, для реализации множества с отсортированными значениями).
   - **Когда не использовать:** 
     - Если нет необходимости в поддержке порядка, так как `HashSet` обеспечивает лучшую производительность (O(1) против O(log n)).

5. **`HashMap`**
   - **Когда использовать:** 
     - Если требуется быстрое добавление, удаление и доступ к элементам по ключу. 
   - **Когда не использовать:** 
     - Если важен порядок ключей, так как `HashMap` не гарантирует порядка.

6. **`TreeMap`**
   - **Когда использовать:** 
     - Если важен отсортированный порядок ключей (например, при работе с диапазонами значений или когда важно поддерживать порядок ключей).
   - **Когда не использовать:** 
     - Если порядок не важен, лучше использовать `HashMap` для лучшей производительности.

7. **`PriorityQueue`**
   - **Когда использовать:** 
     - Когда важен приоритет элементов, и они должны извлекаться в порядке их приоритета. Например, для задач, где важен порядок обработки элементов.
   - **Когда не использовать:** 
     - Если требуется доступ к элементам по индексу или требуется поддерживать общий порядок вставки.

8. **`ArrayDeque`**
   - **Когда использовать:** 
     - Если нужна структура, которая поддерживает быструю вставку и удаление элементов с обеих сторон (например, реализация стэков или деков).
   - **Когда не использовать:** 
     - Если требуется доступ к элементам по индексу или если нужна поддержка порядка элементов, как в `List`.



