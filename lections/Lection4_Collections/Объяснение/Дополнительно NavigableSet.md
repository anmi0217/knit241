### NavigableSet в Java

`NavigableSet` — это интерфейс в Java, который расширяет `SortedSet` и предоставляет дополнительные методы для работы с элементами, упорядоченными в виде отсортированного множества. `NavigableSet` добавляет методы для навигации по множеству, такие как нахождение ближайших элементов (меньших или больших), извлечение первого или последнего элемента, и обратный порядок элементов.

Основная реализация `NavigableSet` — это `TreeSet`, который организует элементы в порядке, определяемом их естественным порядком или компаратором.

#### Основные методы `NavigableSet`

- **`E lower(E e)`**: Возвращает наибольший элемент, который меньше указанного элемента, или `null`, если такого элемента нет.
- **`E floor(E e)`**: Возвращает наибольший элемент, который меньше или равен указанному элементу, или `null`, если такого элемента нет.
- **`E ceiling(E e)`**: Возвращает наименьший элемент, который больше или равен указанному элементу, или `null`, если такого элемента нет.
- **`E higher(E e)`**: Возвращает наименьший элемент, который больше указанного элемента, или `null`, если такого элемента нет.
- **`E pollFirst()`**: Извлекает и удаляет первый (наименьший) элемент множества или возвращает `null`, если множество пустое.
- **`E pollLast()`**: Извлекает и удаляет последний (наибольший) элемент множества или возвращает `null`, если множество пустое.
- **`NavigableSet<E> descendingSet()`**: Возвращает множество с элементами в обратном порядке.

### Пример использования `NavigableSet`

```java
import java.util.NavigableSet;
import java.util.TreeSet;

public class NavigableSetExample {
    public static void main(String[] args) {
        NavigableSet<Integer> numbers = new TreeSet<>();
        numbers.add(1);
        numbers.add(3);
        numbers.add(5);
        numbers.add(7);
        numbers.add(9);

        // Примеры навигации по множеству
        System.out.println("Original Set: " + numbers); // [1, 3, 5, 7, 9]

        // Нахождение ближайших элементов
        System.out.println("Lower than 5: " + numbers.lower(5)); // 3
        System.out.println("Floor of 5: " + numbers.floor(5)); // 5
        System.out.println("Ceiling of 5: " + numbers.ceiling(5)); // 5
        System.out.println("Higher than 5: " + numbers.higher(5)); // 7

        // Извлечение и удаление первого и последнего элемента
        System.out.println("Poll First: " + numbers.pollFirst()); // 1
        System.out.println("Poll Last: " + numbers.pollLast()); // 9
        System.out.println("Set after polling: " + numbers); // [3, 5, 7]

        // Получение множества в обратном порядке
        NavigableSet<Integer> descendingSet = numbers.descendingSet();
        System.out.println("Descending Set: " + descendingSet); // [7, 5, 3]
    }
}
```

**Объяснение:**
- Мы создаем `NavigableSet` на основе `TreeSet` и добавляем в него несколько элементов.
- Используем методы `lower()`, `floor()`, `ceiling()`, и `higher()` для нахождения ближайших элементов относительно указанного значения.
- Методы `pollFirst()` и `pollLast()` извлекают и удаляют первый и последний элементы множества соответственно.
- Метод `descendingSet()` возвращает представление множества с элементами в обратном порядке.

### Особенности и преимущества `NavigableSet`

1. **Отсортированный доступ**: Так как `NavigableSet` расширяет `SortedSet`, элементы всегда поддерживаются в отсортированном порядке. Это удобно для задач, где требуется быстрый доступ к минимальным или максимальным значениям.
2. **Быстрая навигация**: Методы `lower()`, `floor()`, `ceiling()`, и `higher()` позволяют быстро находить ближайшие элементы относительно заданного значения.
3. **Извлечение и удаление элементов**: Методы `pollFirst()` и `pollLast()` полезны для работы с очередями и стеками, где требуется удаление элементов в определенном порядке.
4. **Гибкость порядка**: С помощью метода `descendingSet()` можно легко получить множество с элементами в обратном порядке, что упрощает работу с данными.

### Дополнительные примеры

#### Пример: Использование `NavigableSet` для обработки диапазонов

`NavigableSet` позволяет извлекать подмножества на основе диапазонов, что полезно для задач, связанных с фильтрацией данных.

```java
import java.util.NavigableSet;
import java.util.TreeSet;

public class SubSetExample {
    public static void main(String[] args) {
        NavigableSet<Integer> numbers = new TreeSet<>();
        numbers.add(10);
        numbers.add(20);
        numbers.add(30);
        numbers.add(40);
        numbers.add(50);

        // Извлечение подмножества [20, 40)
        NavigableSet<Integer> subSet = numbers.subSet(20, true, 40, false);
        System.out.println("Subset from 20 (inclusive) to 40 (exclusive): " + subSet); // [20, 30]

        // Извлечение подмножества элементов >= 30
        NavigableSet<Integer> tailSet = numbers.tailSet(30, true);
        System.out.println("Tail Set from 30 (inclusive): " + tailSet); // [30, 40, 50]

        // Извлечение подмножества элементов < 40
        NavigableSet<Integer> headSet = numbers.headSet(40, false);
        System.out.println("Head Set less than 40: " + headSet); // [10, 20, 30]
    }
}
```

**Объяснение:**
- Используем метод `subSet()` для получения подмножества элементов, находящихся в указанном диапазоне.
- Метод `tailSet()` возвращает элементы, начиная с указанного значения (включительно или нет).
- Метод `headSet()` возвращает элементы, которые меньше указанного значения (включительно или нет).

### Заключение

`NavigableSet` — это мощный интерфейс, который предоставляет дополнительные возможности для работы с отсортированными множествами. Его методы позволяют эффективно навигировать и управлять элементами в коллекции, обеспечивая гибкость и производительность при работе с упорядоченными данными. `TreeSet` — основная реализация `NavigableSet`, которая поддерживает все эти функции, и подходит для задач, где важен порядок элементов и быстрый доступ к минимальным и максимальным значениям.