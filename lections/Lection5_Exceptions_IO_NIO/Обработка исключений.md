Продолжим лекцию с рассмотрения механизма обработки исключений в Java. В этой части мы углубимся в основные конструкции и приемы для обработки ошибок.

---

### Обработка исключений

**Основные блоки обработки исключений**

1. **`try-catch` блоки**  
   Основной механизм обработки исключений в Java — это блоки `try-catch`.  
   - Блок `try` заключает код, в котором может возникнуть ошибка. Когда исключение происходит, выполнение кода прерывается, и управление передается в блок `catch`.
   - Блок `catch` перехватывает исключение и позволяет обработать его, выполняя необходимые действия — от вывода сообщения об ошибке до попытки корректного восстановления выполнения программы.  
   
   Пример:
   ```java
   try {
       int result = 10 / 0; // Здесь возникнет ArithmeticException
   } catch (ArithmeticException e) {
       System.out.println("Ошибка: попытка деления на ноль.");
   }
   ```
   В этом примере блок `catch` перехватывает исключение `ArithmeticException` и выводит сообщение, не прерывая выполнение программы.

2. **Ключевое слово `finally`**  
   `finally` — это блок, который всегда выполняется, независимо от того, произошло ли исключение. Этот блок часто используется для освобождения ресурсов, таких как закрытие файлов или завершение сетевых соединений. Он позволяет избежать утечек ресурсов и всегда гарантирует выполнение кода.  
   
   Пример:
   ```java
   try {
       FileInputStream file = new FileInputStream("file.txt");
       // Чтение данных из файла
   } catch (FileNotFoundException e) {
       System.out.println("Файл не найден.");
   } finally {
       // Закрываем файл вне зависимости от успешного выполнения
       if (file != null) {
           file.close();
       }
   }
   ```
   Здесь `finally` гарантирует, что файл будет закрыт в любом случае, предотвращая утечку ресурсов.

---

**Конструкция `try-with-resources`**

Конструкция `try-with-resources` — это улучшение стандартного блока `try-catch`, которое автоматически управляет ресурсами, такими как потоки, соединения и файлы. Эта конструкция появилась в Java 7 и позволяет автоматически закрывать ресурсы, реализующие интерфейс `AutoCloseable`, по завершении работы блока `try`. Это упрощает код и делает его более безопасным.

Пример:
```java
try (FileInputStream file = new FileInputStream("file.txt")) {
    // Чтение данных из файла
} catch (IOException e) {
    System.out.println("Ошибка при работе с файлом.");
}
```
В данном примере ресурс `file` будет автоматически закрыт после завершения блока `try`, даже если возникнет исключение.

---

**Создание своих исключений**

Иногда стандартных исключений в Java недостаточно для описания специфичных ошибок, которые могут возникнуть в вашей программе. В таких случаях можно создать собственные классы исключений, унаследовав их от `Exception` (если это checked исключение) или от `RuntimeException` (если это unchecked исключение).

Пример создания своего исключения:
```java
public class InvalidUserInputException extends Exception {
    public InvalidUserInputException(String message) {
        super(message);
    }
}
```

Теперь это исключение можно использовать для обработки нестандартных ситуаций, характерных именно для вашей программы:
```java
public void validateInput(String input) throws InvalidUserInputException {
    if (input == null || input.isEmpty()) {
        throw new InvalidUserInputException("Некорректный ввод пользователя.");
    }
}
```
В этом примере, если входные данные не соответствуют определенным условиям, выбрасывается исключение `InvalidUserInputException`.

---

**Практические примеры обработки ошибок**

Рассмотрим несколько примеров, где обработка ошибок позволяет защитить программу от сбоев:

1. **Работа с файлами**  
   Часто при работе с файлами возникают исключения, такие как `FileNotFoundException` или `IOException`. Использование `try-catch` или `try-with-resources` помогает предотвратить ошибки и корректно закрыть файл.

   ```java
   try (BufferedReader reader = new BufferedReader(new FileReader("data.txt"))) {
       String line;
       while ((line = reader.readLine()) != null) {
           System.out.println(line);
       }
   } catch (IOException e) {
       System.out.println("Ошибка при чтении файла.");
   }
   ```

2. **Проверка входных данных**  
   Обработка исключений помогает управлять ситуациями, когда данные от пользователя или других систем поступают в неправильном формате, например, деление на ноль или парсинг строки в число.

   ```java
   try {
       int number = Integer.parseInt("abc"); // Это вызовет NumberFormatException
   } catch (NumberFormatException e) {
       System.out.println("Некорректный формат числа.");
   }
   ```

### Finally блок не выполнится если


Блок `finally` обычно гарантированно выполняется после завершения блока `try` или `catch`, однако есть редкие случаи, когда он не выполняется. Вот несколько примеров таких ситуаций:

---

1. **Принудительное завершение программы через `System.exit()`**  
   Если в блоке `try` или `catch` вызывается `System.exit()`, программа завершит выполнение немедленно, и блок `finally` не будет выполнен.

   ```java
   try {
       System.out.println("Выполнение блока try");
       System.exit(0); // Завершение программы
   } catch (Exception e) {
       System.out.println("Выполнение блока catch");
   } finally {
       System.out.println("Этот блок finally не выполнится");
   }
   ```
   В этом случае вызов `System.exit(0)` завершает выполнение программы до того, как управление переходит к блоку `finally`.

---

2. **Сбой питания или принудительное завершение JVM**  
   Если программа столкнется с внезапной потерей питания, падением JVM или аварийной остановкой системы, блок `finally` также не будет выполнен. Это, конечно, трудно воспроизвести программно, но теоретически, при критическом сбое системы, выполнение `finally` не гарантировано.

---

3. **Выброс исключения внутри блока `finally` до завершения его выполнения**  
   Если в блоке `finally` выбрасывается исключение, его выполнение будет прервано, и оставшийся код в `finally` не выполнится. Однако стоит отметить, что сам блок `finally` при этом все равно начнет выполняться, но может не завершиться корректно.

   ```java
   try {
       System.out.println("Выполнение блока try");
   } catch (Exception e) {
       System.out.println("Выполнение блока catch");
   } finally {
       System.out.println("Начало выполнения блока finally");
       if (true) {
           throw new RuntimeException("Исключение в finally");
       }
       System.out.println("Этот код не будет выполнен");
   }
   ```
   В этом примере выбрасывается исключение `RuntimeException` в блоке `finally`, что прерывает его выполнение, и последняя строка блока `finally` не будет достигнута.

---

4. **Падение JVM из-за переполнения стека или нехватки памяти**  
   Если в блоке `try`, `catch` или `finally` происходит переполнение стека (`StackOverflowError`) или ошибка нехватки памяти (`OutOfMemoryError`), выполнение программы может быть прервано полностью, и блок `finally` не выполнится.

   ```java
   try {
       System.out.println("Выполнение блока try");
       recursiveMethod(); // Вызов рекурсивного метода без условия выхода
   } finally {
       System.out.println("Этот блок finally может не выполниться");
   }
   
   public void recursiveMethod() {
       recursiveMethod(); // Бесконечная рекурсия
   }
   ```
   Здесь вызов `recursiveMethod` приводит к бесконечной рекурсии и, в конечном итоге, к переполнению стека, из-за чего JVM прерывает выполнение программы до того, как достигнет блока `finally`.

---

Когда из блока `catch` выбрасывается исключение, блок `finally` всё равно выполняется перед тем, как исключение будет передано дальше. Давайте рассмотрим несколько примеров, чтобы понять, как это работает.

---

### Как отработает finally если исключение будет в блоке catch
### Пример 1: Исключение в блоке `catch`

В этом примере сначала выбрасывается исключение из блока `try`, которое перехватывается блоком `catch`. Затем внутри блока `catch` выбрасывается новое исключение, и перед его передачей блок `finally` выполняется.

```java
try {
    System.out.println("Выполнение блока try");
    int result = 10 / 0; // Это вызовет ArithmeticException
} catch (ArithmeticException e) {
    System.out.println("Исключение перехвачено в блоке catch");
    throw new RuntimeException("Новое исключение из catch"); // Выбрасываем новое исключение
} finally {
    System.out.println("Этот блок finally выполнится, несмотря на исключение в catch");
}
```

**Выходной результат**:
```
Выполнение блока try
Исключение перехвачено в блоке catch
Этот блок finally выполнится, несмотря на исключение в catch
```

В этом примере:
- Блок `finally` выполняется после блока `catch`, даже несмотря на выброс нового исключения из `catch`.
- После выполнения `finally` исключение `RuntimeException` передается дальше, и программа завершится с ошибкой, если это исключение не будет обработано другим `try-catch` блоком выше в стеке вызовов.

---

### Пример 2: Исключение в `catch` и выполнение `finally` для освобождения ресурсов

Рассмотрим случай, когда блок `finally` освобождает ресурсы, даже если из блока `catch` выбрасывается исключение.

```java
public static void main(String[] args) {
    FileInputStream file = null;
    try {
        file = new FileInputStream("somefile.txt");
        // Работа с файлом
    } catch (FileNotFoundException e) {
        System.out.println("Файл не найден, выбрасываем новое исключение");
        throw new RuntimeException("Новое исключение из catch"); // Выбрасываем новое исключение
    } finally {
        System.out.println("Закрытие файла в finally");
        if (file != null) {
            try {
                file.close(); // Попытка закрыть файл
            } catch (IOException ex) {
                System.out.println("Ошибка при закрытии файла");
            }
        }
    }
}
```

**Выходной результат**:
```
Файл не найден, выбрасываем новое исключение
Закрытие файла в finally
```

Здесь:
- Блок `finally` выполняется и пытается закрыть файл, даже если из блока `catch` выбрасывается новое исключение.
- Закрытие файла или освобождение других ресурсов в `finally` происходит независимо от того, выброшено ли исключение из `catch`.
- После выполнения `finally` исключение `RuntimeException` передается дальше.

---

### Пример 3: Вложенный `try-catch` внутри `finally`

Если мы выбросим исключение в `catch`, блок `finally` также может содержать свою собственную обработку исключений. Это позволяет избежать перерыва выполнения, если в `finally` может произойти ошибка при закрытии ресурсов.

```java
try {
    System.out.println("Выполнение блока try");
    int result = 10 / 0; // Это вызовет ArithmeticException
} catch (ArithmeticException e) {
    System.out.println("Исключение перехвачено в блоке catch");
    throw new RuntimeException("Новое исключение из catch"); // Выбрасываем новое исключение
} finally {
    System.out.println("Этот блок finally выполнится");
    try {
        // Например, закрытие соединения с базой данных
        throw new Exception("Ошибка в finally");
    } catch (Exception ex) {
        System.out.println("Исключение перехвачено в finally: " + ex.getMessage());
    }
}
```

**Выходной результат**:
```
Выполнение блока try
Исключение перехвачено в блоке catch
Этот блок finally выполнится
Исключение перехвачено в finally: Ошибка в finally
```

Здесь:
- Исключение из `catch` передается дальше после выполнения блока `finally`.
- Блок `finally` также может перехватывать собственные исключения, если в нем возникает ошибка.
  
---

### Резюме:

1. **Блок `finally` всегда выполняется** после блока `catch`, даже если из `catch` выбрасывается исключение.
2. **Если в `finally` возникает собственное исключение**, оно может быть перехвачено в самом `finally`, что позволит завершить освобождение ресурсов.
3. **Исключение из `catch` передается дальше** после выполнения блока `finally`, если оно не обработано другим `try-catch` блоком выше в стеке вызовов.

В Java **подавленные исключения** (suppressed exceptions) — это исключения, которые возникают, но не выбрасываются напрямую, поскольку основное исключение уже было выброшено. Эта особенность часто возникает в конструкции `try-with-resources`, когда во время закрытия ресурса выбрасывается ошибка, но не перезаписывает исходное исключение. Подавленные исключения могут быть полезны для диагностики и отладки, чтобы не потерять информацию о всех ошибках, возникших при выполнении кода.

### Как работают подавленные исключения

Когда используется конструкция `try-with-resources`, ресурсы автоматически закрываются в конце блока `try`. Если при закрытии ресурса возникает исключение, оно добавляется в список подавленных исключений основного исключения. Это предотвращает перезапись исходной ошибки и позволяет видеть полный набор ошибок, произошедших при выполнении и закрытии ресурсов.

### Пример с подавленными исключениями

Рассмотрим пример, где возникает основное исключение в блоке `try`, и затем происходит исключение при закрытии ресурса в блоке `finally`.

```java
public class SuppressedExceptionExample {
    public static void main(String[] args) {
        try (TestResource resource = new TestResource()) {
            throw new RuntimeException("Основное исключение"); // Исходное исключение
        } catch (RuntimeException e) {
            System.out.println("Поймано основное исключение: " + e.getMessage());
            for (Throwable suppressed : e.getSuppressed()) {
                System.out.println("Подавленное исключение: " + suppressed.getMessage());
            }
        }
    }
}

class TestResource implements AutoCloseable {
    @Override
    public void close() throws Exception {
        throw new Exception("Исключение при закрытии ресурса"); // Исключение при закрытии
    }
}
```

**Выходной результат**:
```
Поймано основное исключение: Основное исключение
Подавленное исключение: Исключение при закрытии ресурса
```

В этом примере:
- Основное исключение выбрасывается в блоке `try`, и его перехватывает `catch`.
- При попытке закрытия ресурса в методе `close()` выбрасывается второе исключение, которое подавляется и добавляется к исходному исключению.
- Мы можем получить доступ к подавленному исключению с помощью метода `getSuppressed()`.

### Как избежать перезаписи исходного исключения

Чтобы не перезаписывать основное исключение и сохранить подавленные, рекомендуется использовать конструкцию `try-with-resources`, которая автоматически добавляет подавленные исключения к основному. Однако, если `try-with-resources` недоступен, например, в старых версиях Java или при использовании `finally`, подавленные исключения можно добавлять вручную с помощью метода `addSuppressed()`.

#### Пример: Добавление подавленных исключений вручную

```java
public class ManualSuppressedExceptionExample {
    public static void main(String[] args) {
        Exception primaryException = null;
        TestResource resource = null;

        try {
            resource = new TestResource();
            throw new RuntimeException("Основное исключение"); // Основное исключение
        } catch (Exception e) {
            primaryException = e;
        } finally {
            if (resource != null) {
                try {
                    resource.close(); // Попытка закрыть ресурс, выбрасывается второе исключение
                } catch (Exception closingException) {
                    if (primaryException != null) {
                        primaryException.addSuppressed(closingException); // Добавляем как подавленное
                    } else {
                        primaryException = closingException;
                    }
                }
            }
        }

        if (primaryException != null) {
            primaryException.printStackTrace();
        }
    }
}
```

В этом примере:
- Основное исключение выбрасывается в блоке `try` и перехватывается в `catch`, где сохраняется в `primaryException`.
- В блоке `finally` ресурс закрывается, и если возникает второе исключение, оно добавляется к `primaryException` как подавленное через `addSuppressed()`.
- Таким образом, исходное исключение не теряется, и все исключения сохраняются для дальнейшей диагностики.

### Резюме

- **Подавленные исключения** — это вторичные исключения, которые могут возникнуть при закрытии ресурсов и добавляются к основному исключению, не перезаписывая его.
- **Конструкция `try-with-resources`** автоматически обрабатывает подавленные исключения, сохраняя их для анализа.
- Для **добавления подавленных исключений вручную** можно использовать метод `addSuppressed()`, чтобы не потерять вторичные исключения в обычных `try-catch-finally` блоках.
