
---


**Что такое исключения**  
Исключения (Exceptions) — это события, которые нарушают нормальный ход выполнения программы. Они могут возникать из-за ошибок в коде, некорректных входных данных или проблем во внешней системе (например, ошибки при работе с файлами). Обработка исключений — это механизм, позволяющий контролировать поведение программы при возникновении ошибок, предотвращать её аварийное завершение и обеспечивать более безопасное выполнение кода.

Java предлагает мощную систему обработки ошибок, благодаря которой можно предсказать возможные ошибки и реагировать на них, обеспечивая надежность и читаемость кода.

---

### Типы исключений

**Checked и Unchecked exceptions**  
В Java исключения делятся на два типа:

1. **Checked exceptions (проверяемые исключения)**:  
   Эти исключения должны быть явно обработаны или проброшены дальше по цепочке вызовов. Если не сделать этого, программа не скомпилируется. Checked исключения проверяются во время компиляции и требуют явного указания `try-catch` или `throws`.  
   Примеры:  
   - `IOException`: может возникнуть при попытке работы с файлами, когда файл недоступен или отсутствует.
   - `SQLException`: может возникнуть при попытке выполнения запросов к базе данных.

2. **Unchecked exceptions (непроверяемые исключения)**:  
   Эти исключения не проверяются на этапе компиляции. Они наследуются от `RuntimeException` и возникают в ходе выполнения программы, зачастую по причине логических ошибок в коде. Unchecked исключения можно не обрабатывать, но при этом важно помнить, что это может привести к непредсказуемым последствиям.  
   Примеры:  
   - `NullPointerException`: возникает при попытке вызова метода или обращения к полю на объекте, равном `null`.
   - `ArithmeticException`: возникает при попытке некорректных математических операций, например деления на ноль.

---

### Иерархия классов исключений


![exception_hierarh.png](..%2F..%2Fcommon%2Fexception_hierarh.png)

Все исключения в Java являются наследниками класса `Throwable`, который делится на два основных подкласса:

1. **`Exception`**  
   Этот класс используется для большинства исключений. В него входят как проверяемые, так и непроверяемые исключения.  
   Примеры:
   - `IOException`
   - `SQLException`
   - `RuntimeException` (и его наследники, такие как `NullPointerException`, `ArithmeticException` и т. д.)

2. **`Error`**  
   `Error` представляет собой ошибки, которые указывают на проблемы с самой JVM (например, `OutOfMemoryError`). Эти ошибки не рекомендуется обрабатывать, так как они, как правило, критичны и требуют перезапуска программы или системы.  

Подкласс **`RuntimeException`** в структуре `Exception` играет важную роль, так как именно от него наследуются непроверяемые исключения, которые могут возникать из-за ошибок в логике программы.

В Java обрабатываемые исключения (checked exceptions) подчиняются правилам наследования, которые определяют, как их можно переопределять и обрабатывать в дочерних классах. Рассмотрим эти правила на примерах.

### Основные правила наследования обрабатываемых исключений

1. **Дочерний класс может выбрасывать те же checked исключения, что и родительский, или их подклассы**. Это позволяет дочернему классу сохранять обратную совместимость с родительским классом, выбрасывая только те исключения, которые ожидаются в родительском классе.

2. **Дочерний класс не может выбрасывать новые checked исключения**, которых нет в сигнатуре метода родительского класса. Если дочерний класс попытается выбросить checked исключение, не объявленное в родительском методе, это приведет к ошибке компиляции.

3. **Если родительский метод не выбрасывает checked исключения, дочерний класс также не может их выбрасывать**. Это связано с тем, что в сигнатуре дочернего метода должно соблюдаться контрактное ограничение метода родительского класса.

### Примеры

#### Пример 1: Дочерний класс выбрасывает то же исключение, что и родительский класс

```java
class Parent {
    public void method() throws IOException {
        // Код, который может выбросить IOException
    }
}

class Child extends Parent {
    @Override
    public void method() throws IOException { // ОК: выбрасывается то же исключение
        // Код, который может выбросить IOException
    }
}
```

В этом примере метод `method` в классе `Child` выбрасывает `IOException`, как и метод в классе `Parent`. Это допустимо, так как дочерний класс повторяет сигнатуру родительского метода.

#### Пример 2: Дочерний класс выбрасывает подкласс checked исключения родительского класса

```java
class Parent {
    public void method() throws IOException {
        // Код, который может выбросить IOException
    }
}

class Child extends Parent {
    @Override
    public void method() throws FileNotFoundException { // ОК: выбрасывается подкласс IOException
        // Код, который может выбросить FileNotFoundException
    }
}
```

Здесь `FileNotFoundException` является подклассом `IOException`, и это допустимо. Метод в дочернем классе может выбрасывать более конкретное исключение, чем метод в родительском классе.

#### Пример 3: Дочерний класс не может выбрасывать новое checked исключение

```java
class Parent {
    public void method() throws IOException {
        // Код, который может выбросить IOException
    }
}

class Child extends Parent {
    @Override
    public void method() throws SQLException { // Ошибка компиляции: выбрасывается новое исключение
        // Код, который может выбросить SQLException
    }
}
```

В этом примере метод `method` в дочернем классе `Child` пытается выбросить исключение `SQLException`, которого нет в сигнатуре родительского метода `method` в классе `Parent`. Это вызовет ошибку компиляции, так как дочерний метод не может добавлять новые checked исключения.

#### Пример 4: Родительский метод не выбрасывает checked исключения

```java
class Parent {
    public void method() {
        // Код метода
    }
}

class Child extends Parent {
    @Override
    public void method() throws IOException { // Ошибка компиляции
        // Код, который может выбросить IOException
    }
}
```

В этом примере родительский метод `method` не выбрасывает никаких checked исключений, поэтому дочерний метод `method` в классе `Child` не может выбрасывать `IOException`. Попытка добавить checked исключение в дочернем классе приведет к ошибке компиляции.

### Резюме

1. **Дочерний класс может выбрасывать те же checked исключения, что и родительский, или их подклассы.**
2. **Дочерний класс не может выбрасывать новые checked исключения, отсутствующие в родительском методе.**
3. **Если родительский метод не выбрасывает checked исключения, дочерний также не может их выбрасывать.**

### Хэндлеры исключений

В Java существует несколько типов обработчиков (или хендлеров) исключений, которые позволяют управлять их обработкой в разных частях программы и на разных уровнях исполнения. Вот основные из них:

### 1. **Блоки `try-catch`**

Наиболее распространенный и явный способ обработки исключений — использование блоков `try-catch`. Они позволяют локально перехватывать и обрабатывать исключения, возникающие в определенном блоке кода.

```java
try {
    int result = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Перехвачено исключение деления на ноль: " + e.getMessage());
}
```

### 2. **Блок `finally`**

Блок `finally` используется для выполнения кода, который должен быть выполнен независимо от того, произошло ли исключение. Чаще всего он используется для освобождения ресурсов, например, закрытия файлов или освобождения сетевых подключений.

```java
try {
    // Код, который может выбросить исключение
} catch (Exception e) {
    // Обработка исключения
} finally {
    // Код, который выполняется в любом случае
}
```

### 3. **Конструкция `try-with-resources`**

Конструкция `try-with-resources` (доступна с Java 7) позволяет автоматически управлять ресурсами, которые реализуют интерфейс `AutoCloseable`. Это гарантирует, что ресурсы будут закрыты автоматически, даже если возникнет исключение.

```java
try (FileInputStream file = new FileInputStream("file.txt")) {
    // Работа с файлом
} catch (IOException e) {
    System.out.println("Ошибка при работе с файлом: " + e.getMessage());
}
```

### 4. **Переопределение метода `uncaughtException` в `Thread.UncaughtExceptionHandler`**

Для работы с неперехваченными исключениями в отдельных потоках Java предоставляет интерфейс `Thread.UncaughtExceptionHandler`. Метод `uncaughtException` вызывается, если в потоке произошло исключение, которое не было обработано. Это полезно для централизованной обработки исключений в многопоточных приложениях.

```java
public class ExceptionHandlerExample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            throw new RuntimeException("Исключение в потоке");
        });

        thread.setUncaughtExceptionHandler((t, e) -> {
            System.out.println("Перехвачено исключение в потоке " + t.getName() + ": " + e.getMessage());
        });

        thread.start();
    }
}
```

### 5. **Глобальный обработчик исключений для всего приложения (`Thread.setDefaultUncaughtExceptionHandler`)**

С помощью метода `Thread.setDefaultUncaughtExceptionHandler` можно установить глобальный обработчик исключений, который будет обрабатывать все неперехваченные исключения в приложении. Это полезно для регистрации всех необработанных ошибок и создания отчетов об ошибках.

```java
public class GlobalExceptionHandlerExample {
    public static void main(String[] args) {
        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {
            System.out.println("Глобально перехвачено исключение: " + e.getMessage());
        });

        new Thread(() -> {
            throw new RuntimeException("Ошибка в потоке 1");
        }).start();

        new Thread(() -> {
            throw new RuntimeException("Ошибка в потоке 2");
        }).start();
    }
}
```

### 6. **Обработчики исключений на уровне фреймворков (например, `ExceptionHandler` в Spring)**

Во многих фреймворках, таких как Spring, предусмотрены специальные аннотации и механизмы для обработки исключений на уровне контроллеров и сервисов. Например, в Spring можно использовать аннотацию `@ExceptionHandler` для указания метода, который будет обрабатывать конкретные типы исключений.

```java
@RestController
public class MyController {

    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<String> handleRuntimeException(RuntimeException e) {
        return new ResponseEntity<>("Произошла ошибка: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

### 7. **Специальные обработчики исключений для потоков JavaFX и Swing**

В JavaFX и Swing, где GUI-код выполняется в одном потоке, существуют обработчики для управления исключениями, возникающими в пользовательском интерфейсе. Например, в JavaFX можно установить глобальный обработчик исключений через `Thread.setDefaultUncaughtExceptionHandler`, чтобы все исключения, возникающие в JavaFX Application Thread, обрабатывались централизованно.

```java
Thread.setDefaultUncaughtExceptionHandler((thread, throwable) -> {
    System.out.println("Перехвачено исключение в JavaFX Application Thread: " + throwable.getMessage());
});
```

### 8. **Logger для записи необработанных исключений**

Хотя это не является напрямую "хендлером" исключений, использование логгеров для записи информации об исключениях (например, `java.util.logging.Logger` или `Log4j`) помогает регистрировать все неперехваченные ошибки и отслеживать их. В логгере можно настраивать уровни и формат сообщений, что позволяет централизованно управлять выводом ошибок.

```java
import java.util.logging.Logger;

public class LoggingExceptionExample {
    private static final Logger logger = Logger.getLogger(LoggingExceptionExample.class.getName());

    public static void main(String[] args) {
        try {
            int result = 10 / 0;
        } catch (Exception e) {
            logger.severe("Ошибка: " + e.getMessage());
        }
    }
}
```

### Резюме

Java предоставляет несколько способов и уровней обработки исключений:

- Локальные блоки `try-catch` и `finally`.
- Конструкция `try-with-resources` для автоматического управления ресурсами.
- Обработчики `UncaughtExceptionHandler` для потоков и глобальный обработчик для всего приложения.
- Обработчики на уровне фреймворков, таких как Spring.
- Логгеры для записи информации об исключениях.

Эти методы позволяют создавать надежные программы с централизованным управлением исключениями и обеспечивают гибкость при работе с ошибками в разных частях приложения.