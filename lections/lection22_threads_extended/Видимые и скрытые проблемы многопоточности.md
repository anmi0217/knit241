### **Видимые и скрытые проблемы многопоточности**

#### **1. Гонки данных (Race Condition)**

Гонка данных возникает, когда несколько потоков одновременно читают и записывают одну переменную без должной синхронизации. Это приводит к непредсказуемым результатам.

Пример гонки данных:
```java
class SharedResource {
    private int value = 0;

    public void increment() {
        value++;
    }

    public int getValue() {
        return value;
    }
}
```

Если два потока вызывают `increment()`, возможен сбой.

✅ **Решение:** использование `synchronized`, `AtomicInteger`.

#### **2. Порядок выполнения инструкций (Reordering)**

Современные процессоры и компиляторы могут изменять порядок выполнения команд для оптимизации производительности. Однако это может привести к неожиданным эффектам в многопоточной среде.

Пример:
```java
class ReorderingExample {
    int a = 0, b = 0, x = 0, y = 0;

    public void thread1() {
        a = 1;       // (1)
        x = b;       // (2)
    }

    public void thread2() {
        b = 1;       // (3)
        y = a;       // (4)
    }
}

```

Хотя логически кажется, что `x == 1 || y == 1`, из-за **реорганизации команд (instruction reordering)** возможно `x == 0 && y == 0`.

✅ **Решение:** использование `volatile` или `synchronized`, которые гарантируют **happens-before** порядок выполнения.

#### **3. Кеширование значений (Visibility Issues)**

Переменные могут храниться в **кэше процессора**, а не в основной памяти. Это приводит к тому, что изменения, сделанные одним потоком, могут быть **невидимы** для другого.

Пример:

```java
class SharedData {
    private boolean running = true;

    public void stop() {
        running = false;  // Может не обновиться в другом потоке
    }

    public void run() {
        while (running) {
            // Выполняется бесконечно, если running не обновится!
        }
    }
}

```

Если поток читает `running` из **кэша**, а другой поток изменяет его в **основной памяти**, изменения могут быть не видны.

✅ **Решение:** использовать `volatile`:

```java
private volatile boolean running = true;

```


### **Когда не нужна синхронизация?**

✅ **Случаи, когда можно избежать синхронизации:**

1.  **Immutable объекты**
    - Если объект не изменяется после создания (`String`, `Integer`, `LocalDateTime`), его можно свободно использовать в потоках.
2. **Поток-локальные переменные (`ThreadLocal`)**
    
    - Каждому потоку создается своя копия переменной:
```java
  private static ThreadLocal<Integer> threadLocal = 
  ThreadLocal.withInitial(() > 0);

```

  3. **Использование `Concurrent` коллекций**
    `ConcurrentHashMap`, `CopyOnWriteArrayList` уже потокобезопасны.
1. **Lock-free алгоритмы**
	Использование `Atomic` переменных (`AtomicInteger`, `AtomicReference`) вместо `synchronized`.