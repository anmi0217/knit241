

---

### **1. Введение в проблему синхронизации в многопоточных приложениях**

- Почему необходима синхронизация?
- [Видимые и скрытые проблемы многопоточности](%D0%92%D0%B8%D0%B4%D0%B8%D0%BC%D1%8B%D0%B5%20%D0%B8%20%D1%81%D0%BA%D1%80%D1%8B%D1%82%D1%8B%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%8B%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D0%B8.md) (гонки данных, порядок выполнения инструкций, кеширование значений)
- Когда не нужна синхронизация?

---

### **2. [Модификатор volatile](%D0%9C%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%20volatile.md)**

- Что делает `volatile`?
- Обеспечение видимости изменений переменной между потоками
- Гарантия порядка операций (happens-before)
- Ограничения `volatile`:
    - Не обеспечивает атомарности сложных операций (например, `i++`)
    - Не подходит для синхронизации нескольких переменных
- Примеры использования `volatile`:
    - Флаг остановки потока (`volatile boolean running`)
    - Двойная проверка (Double-Checked Locking)

---

### **3. [Атомарные переменные](%D0%90%D1%82%D0%BE%D0%BC%D0%B0%D1%80%D0%BD%D1%8B%D0%B5%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5.md)(java.util.concurrent.atomic)**

- Зачем нужны атомарные переменные?
- `AtomicInteger`, `AtomicLong`, `AtomicReference` и другие
- Принцип работы на основе CAS (Compare-And-Swap)
- Пример: счетчик с `AtomicInteger`
- Ограничения: атомарность только на уровне одной переменной

---

### **4. [Singleton](Singleton.md) Потокобезопасный синглетон** 

- Опасности ленивой инициализации (`lazy initialization`)
- Подходы к реализации потокобезопасного синглтона:
    1. **Использование `synchronized`** (прост, но неэффективен)
    2. **Double-Checked Locking с `volatile`** (эффективный вариант)
    3. **Использование `static final` (инициализация при загрузке класса)**
    4. **Использование `enum` (гарантированная потокобезопасность от JVM)**
- Примеры кода для каждого варианта

---

### **5. Синхронизация с  [CountDownlatch](CountDownlatch.md)

- Что такое `CountDownLatch`?
- Принцип работы: защелка с обратным отсчетом
- Реальный пример: ожидание завершения N задач перед продолжением работы главного потока
- Пример кода с `CountDownLatch`

---

### **6. Синхронизация с [Cyclic Barier](Cyclic%20Barier.md)**

- В чем отличие от `CountDownLatch`?
- Использование `CyclicBarrier` для синхронизации групп потоков
- Возможность повторного использования (`reset()`)
- Реальный пример: командная работа в потоках
- Пример кода с `CyclicBarrier`

---
[ReentrantLock](ReentrantLock.md)



### **7. Дополнение [Прерывание потоков](%D0%9F%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2.md)

